using QuazarAPI.Networking.Data;
using nio2so.TSOTCP.City.TSO.Voltron.Serialization;
using nio2so.TSOTCP.City.TSO.Voltron.Util;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MiscUtil.Conversion;

namespace nio2so.TSOTCP.City.TSO.Voltron.PDU.Datablob
{
    internal class TSOBroadcastDatablobPDUHeader : ITSOVoltronSpecializedPDUHeader
    {
        public string AriesID { get; set; } = "";
        public string MasterID { get; set; } = "";
        public ushort Arg1 { get; set; }
        public uint MessageLength { get; set; }
        public TSO_PreAlpha_MasterConstantsTable SubMsgCLSID { get; set; }        
    }

    /// <summary>
    /// Basically packs and ships data of a defined format to the server with the intention to send it to all connected parties
    /// in the Room Server
    /// <para/>As a sidenote (not like anyone reads these but me any way) why is everything called a blob? idk me, why don't you ask them?
    /// well i tried but this was made 20 years ago. why am i even doing this?
    /// </summary>
    [TSOVoltronPDU(TSO_PreAlpha_VoltronPacketTypes.BROADCAST_DATABLOB_PDU)]
    internal abstract class TSOBroadcastDatablobPacket : TSOVoltronSpecializedPacket<TSOVoltronBroadcastDatablobPDUField, TSOBroadcastDatablobPDUHeader>, 
        ITSOVoltronAriesMasterIDStructure
    {
        private const uint MESSAGELENGTH_TO_BODY = sizeof(uint);

        public override ushort VoltronPacketType => (ushort)TSO_PreAlpha_VoltronPacketTypes.BROADCAST_DATABLOB_PDU;
        protected override TSOBroadcastDatablobPDUHeader Header { get; } = new();

        [TSOVoltronString]
        public string AriesID
        {
            get => Header.AriesID;
            set => Header.AriesID = value;
        }
        [TSOVoltronString] public string MasterID
        {
            get => Header.MasterID;
            set => Header.MasterID = value;
        }
        public ushort Arg1
        {
            get => Header.Arg1;
            set => Header.Arg1 = value;
        }
        [TSOVoltronDistanceToEnd] public uint MessageLength
        {
            get => Header.MessageLength;
            set => Header.MessageLength = value;
        }
        public TSO_PreAlpha_MasterConstantsTable SubMsgCLSID
        {
            get => Header.SubMsgCLSID;
            set => Header.SubMsgCLSID = value;
        }

        /// <summary>
        /// This is the default, parameterless constuctor.
        /// <para/>You should use this in two scenarios: Using reflection to instantiate an instance of a type of 
        /// <see cref="TSODBRequestWrapper"/> OR writing a <see cref="TSODBRequestWrapper"/> that has a <see cref="TSODBRequestWrapper.kMSGID"/>
        /// that is: <see cref="TSO_PreAlpha_kMSGs.kDBServiceRequestMsg"/> as this is sent from the Client and the structure is not generated by the
        /// nio2so <see cref="TSOVoltronPacket"/> API        
        /// </summary>
        public TSOBroadcastDatablobPacket() : base()
        {
            MakeBodyFromProperties();
        }

        /// <summary>
        /// Creates a new <see cref="TSODBRequestWrapper"/> PDU where the argument list has been
        /// simplified to automate more of the properties that can be confusing otherwise.
        /// </summary>
        /// <param name="StructCLSID"></param>
        /// <param name="kMSG_ID"></param>
        /// <param name="DBAction"></param>
        /// <param name="Header"></param>
        /// <param name="Payload"></param>
        public TSOBroadcastDatablobPacket(TSO_PreAlpha_MasterConstantsTable SubMsgCLSID, uint MessageLength = 0xFFFFFFFF)
        {
            this.SubMsgCLSID = SubMsgCLSID;

            this.MessageLength = MessageLength;
            MakeBodyFromProperties();
        }

        /// <summary>
        /// Will read from the point just after the Size of the <see cref="TSOVoltronPacket"/> (0x80...) 2 strings, then a ushort, then read the size.
        /// </summary>
        /// <param name="BodyStream"></param>
        /// <returns></returns>
        public static uint ReadSpecializedPDUBodyLengthFromHeader(Stream BodyStream) => ReadSpecializedPDUHeader(BodyStream).MessageLength;

        /// <summary>
        /// Will read from the point just after the Size of the <see cref="TSOVoltronPacket"/> (0x80...) the <see cref="TSODBWrapperPDUHeader"/>
        /// </summary>
        /// <param name="BodyStream"></param>
        /// <returns></returns>
        public static TSOBroadcastDatablobPDUHeader ReadSpecializedPDUHeader(Stream BodyStream)
        {
            var startPosition = BodyStream.Position;
            var avatarID = TSOVoltronBinaryReader.ReadString(TSOVoltronValueTypes.Pascal, BodyStream);
            var avatarName = TSOVoltronBinaryReader.ReadString(TSOVoltronValueTypes.Pascal, BodyStream);
            ushort arg1 = BodyStream.ReadBodyUshort(Endianness.BigEndian);
            uint msgSize = BodyStream.ReadBodyDword(Endianness.BigEndian);
            uint actionCLSID = BodyStream.ReadBodyDword();
            BodyStream.Seek(startPosition, SeekOrigin.Begin);
            return new()
            {
                AriesID = avatarID,
                MasterID = avatarName,
                Arg1 = arg1,
                MessageLength = msgSize,
                SubMsgCLSID = (TSO_PreAlpha_MasterConstantsTable)actionCLSID
            };
        }

        /// <summary>
        /// Use this function to extend the Body property to the <see cref="MessageLength"/> parameter.
        /// <para>See: <see cref="MessageLength"/> property for more info.</para>
        /// </summary>
        protected void FillPacketToAvailableSpace()
        {
            //TSOPacketFormat + Flags + TransID + SubMSgCLSID + CurrentBodySize
            long currentSize = BodyLength;
            int delta = (int)(Header.MessageLength - currentSize); // size diff
            if (delta <= 0) return; // yikes, not necessary to even do this.
            long newSize = delta + BodyLength;
            byte[] trash = new byte[delta];
            ReallocateBody((uint)newSize);
            EmplaceBodyAt((int)BodyLength - delta, trash);
            currentSize = (int)MESSAGELENGTH_TO_BODY + BodyLength;
            if (currentSize != MessageLength)
                throw new Exception("This should never happen.");
        }

        public override string ToShortString(string Arguments = "") => ToString();
        public override string ToString()
        {
            return $"{GetType().Name}({SubMsgCLSID}, byte[{MessageLength}])";
        }
    }
}
